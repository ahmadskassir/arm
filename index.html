<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robotic Arm</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; direction: rtl; }
        .container { display: table; max-width: 2500px; margin: auto; padding: 20px; background-color: white; border-radius: 2px; }
        .container2 { display: table-cell; max-width: 1000px; padding: 20px; background-color: white; border-radius: 2px; }
        h1 { text-align: center; color: #333; }
        h2 { text-align: center; color: #555; }
        label { display: block; margin: 7px 0 5px; font-weight: bold; }
        input { width: 100%; padding: 8px; margin-bottom: 7px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button { width: 100%; padding: 10px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { background-color: #218838; }
        #result { margin-top: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background-color: #f9f9f9; }
        .error { color: red; font-weight: bold; }
        .plot-container { margin-top: 20px; text-align: center; }
        canvas { border: 1px solid #ccc; border-radius: 4px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background-color: #f4f4f4; }
    </style>
</head>
<body>
<div class="container">
    <div class="container2">
        <h1>حساب حركيات الذراع الروبوتية</h1>
        <form id="ikForm">
            <input type="checkbox" id="modeCheckbox"> استخدام الزوايا لحساب النقطة النهائية<br><br>
            <div id="pointInputs">
                <label for="startX">Start X (0-10):</label>
                <input type="number" id="startX" step="0.1" min="0" max="10" required>
                <label for="startY">Start Y (0-10):</label>
                <input type="number" id="startY" step="0.1" min="0" max="10" required>
                <label for="endX">End X (0-10):</label>
                <input type="number" id="endX" step="0.1" min="0" max="10" required>
                <label for="endY">End Y (0-10):</label>
                <input type="number" id="endY" step="0.1" min="0" max="10" required>
            </div>
            <div id="angleInputs" style="display: none;">
                <label for="theta1">θ₁ (°):</label>
                <input type="number" id="theta1" step="0.1" required>
                <label for="theta2">θ₂ (°):</label>
                <input type="number" id="theta2" step="0.1" required>
                <label for="theta3">θ₃ (°):</label>
                <input type="number" id="theta3" step="0.1" required>
            </div>
            <label for="L1">طول الرابط 1:</label>
            <input type="number" id="L1" step="0.1" min="0.1" required>
            <label for="L2">طول الرابط 2:</label>
            <input type="number" id="L2" step="0.1" min="0.1" required>
            <label for="L3">طول الرابط 3:</label>
            <input type="number" id="L3" step="0.1" min="0.1" required>
            <button type="submit">احسب</button>
        </form>
        <div id="result"></div>
        <div class="plot-container">
            <h2>محاكاة الذراع</h2>
            <canvas id="armCanvas" width="1000" height="750"></canvas>
        </div>
        <p> 
            S1: النقطة في نهاية الرابط 1<br>
            S2: النقطة في نهاية الرابط 2<br>
            S3: النقطة في نهاية الرابط 3<br>
            النقطة الخضراء الصغيرة: أساس الروبوت (0,0)<br>
            النقطة الخضراء الكبيرة: نقطة البداية<br>
            النقطة البنفسجية: النقطة النهائية<br>
            θ₁: الزاوية بين الرابط 1 ومحور X<br>
            θ₂: الزاوية بين الرابط 1 والرابط 2<br>
            θ₃: الزاوية بين الرابط 2 والرابط 3
        </p>
    </div>
    <div class="container2">
        <h2>جدول البيانات</h2>
        <table id="dataTable">
            <thead>
                <tr>
                    <th>الخطوة</th>
                    <th>θ₁ (°)</th>
                    <th>θ₂ (°)</th>
                    <th>θ₃ (°)</th>
                    <th>s1 X</th>
                    <th>s1 Y</th>
                    <th>s2 X</th>
                    <th>s2 Y</th>
                    <th>s3 X</th>
                    <th>s3 Y</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<script>
    let dataRecords = [];
    const checkbox = document.getElementById('modeCheckbox');
    const angleInputs = document.getElementById('angleInputs');
    const pointInputs = document.getElementById('pointInputs');

    // تبديل رؤية الحقول بناءً على حالة الـ checkbox
    checkbox.addEventListener('change', function() {
        if (this.checked) {
            angleInputs.style.display = 'block';
            pointInputs.style.display = 'none';
        } else {
            angleInputs.style.display = 'none';
            pointInputs.style.display = 'block';
        }
    });

    document.getElementById('ikForm').addEventListener('submit', function(e) {
        e.preventDefault();
        dataRecords = []; // إعادة تعيين السجلات

        const inputs = {
            startX: parseFloat(document.getElementById('startX').value),
            startY: parseFloat(document.getElementById('startY').value),
            endX: parseFloat(document.getElementById('endX').value),
            endY: parseFloat(document.getElementById('endY').value),
            L1: parseFloat(document.getElementById('L1').value),
            L2: parseFloat(document.getElementById('L2').value),
            L3: parseFloat(document.getElementById('L3').value),
            theta1: parseFloat(document.getElementById('theta1').value),
            theta2: parseFloat(document.getElementById('theta2').value),
            theta3: parseFloat(document.getElementById('theta3').value)
        };

        // التحقق من أطوال الروابط
        if ([inputs.L1, inputs.L2, inputs.L3].some(isNaN) || [inputs.L1, inputs.L2, inputs.L3].some(v => v <= 0)) {
            showError('يجب أن تكون أطوال الروابط موجبة وصالحة');
            return;
        }

        if (checkbox.checked) {
            // الطور الثاني: Forward Kinematics
            if (isNaN(inputs.theta1) || isNaN(inputs.theta2) || isNaN(inputs.theta3)) {
                showError('الرجاء إدخال زوايا صالحة');
                return;
            }

            const theta1Rad = inputs.theta1 * Math.PI / 180;
            const theta2Rad = inputs.theta2 * Math.PI / 180;
            const theta3Rad = inputs.theta3 * Math.PI / 180;

            const angles = [theta1Rad, theta2Rad, theta3Rad];
            const endPoint = calculateFK(angles[0], angles[1], angles[2], inputs.L1, inputs.L2, inputs.L3);

            // رسم الذراع وعرض النتيجة
            const points = drawArmFK(inputs, angles, endPoint);
            recordData(0, angles, points);
            fillDataTable();
            showEndPoint(endPoint);
        } else {
            // الطور الأساسي: Inverse Kinematics
            if ([inputs.startX, inputs.startY, inputs.endX, inputs.endY].some(isNaN)) {
                showError('الرجاء إدخال إحداثيات صالحة');
                return;
            }
            if ([inputs.startX, inputs.startY, inputs.endX, inputs.endY].some(v => v < 0 || v > 10)) {
                showError('يجب أن تكون الإحداثيات بين 0 و10');
                return;
            }

            const path = generatePath(inputs.startX, inputs.startY, inputs.endX, inputs.endY, 50);
            const solutions = path.map(point => calculateIK(point.x, point.y, inputs.L1, inputs.L2, inputs.L3));
            const reachableSolutions = solutions.filter(s => s !== null);

            if (reachableSolutions.length === 0) {
                showError('الموقع المستهدف غير قابل للوصول');
                clearCanvas();
                return;
            }

            animateArm(inputs, reachableSolutions, 0);
        }
    });

    // دالة لحساب النقطة النهائية باستخدام Forward Kinematics
    function calculateFK(theta1, theta2, theta3, L1, L2, L3) {
        const x = L1 * Math.cos(theta1) + L2 * Math.cos(theta1 + theta2) + L3 * Math.cos(theta1 + theta2 + theta3);
        const y = L1 * Math.sin(theta1) + L2 * Math.sin(theta1 + theta2) + L3 * Math.sin(theta1 + theta2 + theta3);
        return { x, y };
    }

    function generatePath(startX, startY, endX, endY, steps) {
        const path = [];
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = startX + t * (endX - startX);
            const y = startY + t * (endY - startY);
            path.push({ x, y });
        }
        return path;
    }

    function calculateIK(x, y, L1, L2, L3) {
        const distance = Math.sqrt(x * x + y * y);
        const totalLength = L1 + L2 + L3;
        if (distance > totalLength || distance < Math.abs(L1 - L2 -